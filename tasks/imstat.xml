<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" ?>

<casaxml xmlns="http://casa.nrao.edu/schema/psetTypes.html"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://casa.nrao.edu/schema/casa.xsd
file:///opt/casa/code/xmlcasa/xml/casa.xsd">


<!-- This is the image statitics task                         -->

<task type="function" name="imstat" category="analysis, information">
<shortdescription>Displays statistical information from an image or image region</shortdescription>

<input>
    <param type="string" name="imagename" kind="image" mustexist="true" >
    	<description>Name of the input image</description>
    	<value/>
        <example>imagename=ngc5921_task.image</example>
    </param>
    <param type="any" name="axes">
        <any type="variant"/>
        <description>List of axes to evaluate statistics over. Default is all axes.</description>
        <value>-1</value>
        <example>[0, 1]</example> 
    </param>
    <param type="string" name="region">
        <description>Image Region or name. Use Viewer</description>
        <value></value>
    </param>
    <param type="string" name="box">
        <description>Select one or more box regions</description>
        <value></value>
    </param>
    <param type="string" name="chans" >
	<description>Select the channel(spectral) range. See "help par.chans" for examples.</description>
    	<value></value>
    </param>
    <param type="string" name="stokes">
	    <description>Stokes params to image (I,IV,IQU,IQUV). Default "" => include all</description>
	    <value></value>
	    <example>stokes=&quot;IQ&quot;</example>
	    <example>stokes=&quot;RR,LL&quot;</example>
    </param>
    <param type="bool" name="listit">
        <description>Print stats and bounding box to logger?</description>
        <value>True</value>
    </param>
    <param type="bool" name="verbose">
        <description>Print additional messages to logger?</description>
        <value>True</value>
    </param>
    <param type="string" direction="in" name="mask">
        <description>Mask to use. See help par.mask. Default is none.</description>
        <value/>
    </param>
    <param type="bool" direction="in" name="stretch" subparam="true">
        <description>Stretch the mask if necessary and possible? See help par.stretch </description>
        <value>False</value>
    </param>
    <param type="string" name="logfile">
        <description>Name of file to write fit results.</description>
        <value/>
        <example>logfile="myimfitlog.txt"</example>
    </param>
    <param type="bool" name="append" subparam="true"> 
        <description>If logfile exists, append to it if True or overwrite it if False</description>
        <value>True</value>
        <example>append=True</example>
    </param>
    <param type="string"  name="algorithm">
          <description>Algorithm to use. Supported values are "chauvenet", "classic", "fit-half", and "hinges-fences". Minimum match is supported.</description>
          <value>classic</value>
     </param>
     <param type="double" name="fence" subparam="true">
          <description>Fence value for hinges-fences. A negative value means use the entire data set (ie default to the "classic" algorithm). Ignored if algorithm is not "hinges-fences".</description>
          <value>-1</value>
     </param>
     <param type="string"  name="center" subparam="true">
          <description>Center to use for fit-half. Valid choices are "mean", "median", and "zero". Ignored if algorithm is not "fit-half".</description>
          <value>mean</value>
     </param>
     <param type="bool"  name="lside" subparam="true">
          <description>For fit-half, use values &lt;= center for real data if True? If False, use values &gt;= center as real data. Ignored if algorithm is not "fit-half".</description>
          <value>True</value>
     </param>
     <param type="double"  name="zscore" subparam="true">
          <description>For chauvenet, this is the target maximum number of standard deviations data may have to be included. If negative, use Chauvenet&quot;s criterion. Ignored if algorithm is not "chauvenet".</description>
          <value>-1</value>
     </param>
     <param type="int"  name="maxiter" subparam="true">
          <description>For chauvenet, this is the maximum number of iterations to attempt. Iterating will stop when either this limit is reached, or the zscore criterion is met. If negative, iterate until the zscore criterion is met. Ignored if algorithm is not "chauvenet".</description>
          <value>-1</value>
     </param>
     <constraints>
        <when param="mask">
            <notequals type="string" value="">
                <default param="stretch">
                    <value type="bool">False</value>
                </default>
            </notequals>
        </when>
        <when param="logfile">
            <notequals type="string" value="">
                <default param="append">
                    <value>True</value>
                </default>
            </notequals>
        </when>
        <when param="algorithm">
            <!--  the first case is necessary to ensure algorithm is set to the correct default value
             The need for this seems to be a bug to me, but I doubt we have anyone who is capable of fixing it -->
            <equals type="string" value="classic"/>
            <equals type="string" value="hinges-fences">
                <default param="fence">
                    <value>-1</value>
                </default>
            </equals>
            <equals type="string" value="fit-half">
                <default param="center">
                    <value type="string">mean</value>
                </default>
                <default param="lside">
                    <value>True</value>
                </default>
            </equals>
            <equals type="string" value="chauvenet">
                <default param="zscore">
                    <value>-1</value>
                </default>
                <default param="maxiter">
                    <value>-1</value>
                </default>
            </equals>
        </when>
    </constraints>
</input>
<returns type="void"/>

<example>

     Many parameters are determined from the specified region of an image.
     For this version, the region can be specified by a set of rectangular
     pixel coordinates, the channel ranges and the Stokes.

     For directed output, run as 
                    myoutput = imstat()
   

Keyword arguments:
imagename    Name of input image
		     Default: none; Example: imagename='ngc5921_task.im'
axes         axes to compute statistics over. -1 => all axes.
region       Region of interest. See help par.region.
box          A box region specified in pixels on the directional plane
		     Default: none (whole 2-D plane); 
             Example: box='10,10,50,50'
             box = '10,10,30,30,35,35,50,50' (two boxes)
chans        Zero based channel numbers
	         Range of channel numbers to include in statistics
             See "help par.chans" for examples. 
		     Default:''= all;  Example: chans='3~20'    
stokes       Stokes parameters to analyze.
             Default: all; Example: stokes='IQUV';  
             Example:stokes='I,Q'
             Options: 'I','Q','U','V','RR','RL','LR','LL','XX','YX','XY','YY', ...
listit       Print stats and bounding box to logger? 
verbose      Print additional messages to logger?
mask         Mask to use. See help par.mask. Default is none.
stretch      Stretch the mask if necessary and possible? See help par.stretch 
logfile      Name of file to write fit results.
append       If logfile exists, append to it (True) or overwrite it (False).
alogortihm   Algorithm to use to compute statistics. Supported values are "classic"
             and "hinges-fences" (minimum match supported.)
fence        Fence factor when algorithm = "hinges-fences". Negative values are not
             applicable and in these cases, the classic algorithm is used.
center       Center to use for "fit-half". Valid choices are "mean" (mean value of the
             selected pixels), "median" (median value of the selected pixels), and "zero"
             (0.0 is used as the center value). Ignored if algorithm is not "fit-half".
lside        For fit-half, use values &lt;= center for the real data? If false, use
             values &gt;= center as the real data. Ignored if algorithm is not "fit-half"
zscore       For chauvenet, this is the target maximum number of standard deviations data
             may have to be included. If negative, use Chauvenet's criterion. Ignored if
             algorithm is not "chauvenet".
maxiter      For chauvenet, this is the maximum number of iterations to attempt. Iterating
             will stop when either this limit is reached, or the zscore criterion is met.
             If negative, iterate until the zscore criterion is met. Ignored if algorithm is
             not "chauvenet".

      General procedure:

         1.  Specify inputs, then

         2.  myoutput = imstat()
               or specify inputs directly in calling sequence to task
             myoutput = imstat(imagename='image.im', etc)

         3.  myoutput['KEYS'] will contain the result associated with any
               of the keys given below
        
        KEYS CURRENTLY AVAILABLE
    	blc          - absolute PIXEL coordinate of the bottom left corner of 
	               the bounding box surrounding the selected region
    	blcf         - Same as blc, but uses WORLD coordinates instead of pixels
    	trc          - the absolute PIXEL coordinate of the top right corner 
                       of the bounding box surrounding the selected region
    	trcf         - Same as trc, but uses WORLD coordinates instead of pixels
        flux         - the integrated flux density if the beam is defined and 
                       the if brightness units are $Jy/beam$
	npts         - the number of unmasked points used
	max          - the maximum pixel value
    	min          - minimum pixel value
	maxpos       - absolute PIXEL coordinate of maximum pixel value
	maxposf      - Same as maxpos, but uses WORLD coordinates instead of pixels
    	minpos       - absolute pixel coordinate of minimum pixel value
	minposf      - Same as minpos, but uses WORLD coordinates instead of pixels
	sum          - the sum of the pixel values: $\sum I_i$
        sumsq        - the sum of the squares of the pixel values: $\sum I_i^2$
	mean         - the mean of pixel values: 
                       $\bar{I} = \sum I_i / n$
	sigma        - the standard deviation about the mean: 
                       $\sigma^2 = (\sum I_i - \bar{I})^2 / (n-1)$
        rms          - the root mean square: 
                       $\sqrt {\sum I_i^2 / n}$
	median       - the median pixel value
	medabsdevmed - the median of the absolute deviations from the 
                       median
	quartile     - the inner-quartile range. Find the points 
                       which are 25% largest and 75% largest (the median is 
                       50% largest).
    q1           - the first quartile.
    q3           - the third quartile


ALGORITHMS

Several types of statistical algorithms are supported:

* classic: This is the familiar algorithm, in which all unmasked data, subject to any
  specified pixel ranges are used.
  
* fit-half: This algorithm calculates statistics on a dataset created from real and virtual pixel values.
  The real values are determined by the input parameters center and lside. The parameter center
  tells the algorithm where the center value of the combined real+virtual dataset should be. Options
  are the mean or the median of the input image's pixel values, or at zero. The lside parameter tells
  the algorithm on which side of this center the real pixel values are located. True indicates that
  the real pixel values to be used are &lt;= center. False indicates the real pixel values to be used
  are &gt;= center. The virtual part of the dataset is then created by reflecting all the real values
  through the center value, to create a perfectly symmetric dataset composed of a real and a virtual
  component. Statistics are then calculated on this resultant dataset. These two parameters are
  ignored if algorithm is not "fit-half". Because the maximum value is virtual if lside is True and the
  minimum value is virtual if lside is False, the value of the maximum position (if lside=True) or
  minimum position (if lside=False) is not reported in the returned record.
  
* hinges-fences: This algorithm calculates statistics by including data in a range
  between Q1 - f*D and Q3 + f*D, inclusive, where Q1 is the first quartile of the distribution
  of unmasked data, subject to any specified pixel ranges, Q3 is the third quartile, D = Q3 - Q1
  (the inner quartile range), and f is the user-specified fence factor. Negative values of f
  indicate that the full distribution is to be used (ie, the classic algorithm is used). Sufficiently
  large values of f will also be equivalent to using the classic algorithm. For f = 0, only data
  in the inner quartile range is used for computing statistics. The value of fence is silently
  ignored if algorithm is not "hinges-fences".

* chauvenet: The idea behind this algorithm is to eliminate outliers based on a maximum z-score value.
  A z-score is the number of standard deviations a point is from the mean of a distribution. This
  method thus is meant to be used for (nearly) normal distributions. In general, this is an iterative
  process, with successive iterations discarding additional outliers as the remaining points become
  closer to forming a normal distribution. Iterating stops when no additional points lie beyond the
  specified zscore value, or, if zscore is negative, when Chauvenet's criterion is met (see below).
  The parameter maxiter can be set to a non-negative value to prematurely abort this iterative
  process.
  
  Chauvenet's criterion allows the target z-score to decrease as the number of points in the
  distribution decreases on subsequent iterations. Essentially, the criterion is that the probability
  of having one point in a normal distribution at a maximum z-score of z_max must be at least 0.5.
  z_max is therefore a function of (only) the number of points in the distrbution and is given by
  
  npts = 0.5/erfc(z_max/sqrt(2))
  
  where erfc() is the complementary error function. As iterating proceeds, the number of remaining
  points decreases as outliers are discarded, and so z_max likewise decreases. Convergence occurs when
  all remaining points fall within a z-score of z_max. Below is an illustrative table of z_max values
  and their corresponding npts values. For example, it is likely that there will be a 5-sigma "noise
  bump" in a perfectly noisy image with one million independent elements.
  
  z_max    npts
  1.0                1
  1.5                3
  2.0               10
  2.5               40
  3.0              185
  3.5            1,074
  4.0            7,893
  4.5           73,579
  5.0          872,138
  5.5       13,165,126
  6.0      253,398,672
  6.5    6,225,098,696
  7.0  195,341,107,722

ADDITIONAL EXAMPLES

	# Selected two box region
	# box 1, bottom-left coord is 2,3 and top-right coord is 14,15
	# box 2, bottom-left coord is 30,31 and top-right coord is 42,43
	imstat( 'myImage', box='2,3,14,15;30,31,42,43' )

	# Select the same two box regions but only channels 4 and 5
	imstat( 'myImage', box='2,3,14,15;30,31,42,43', chan='4~5' )

	# Select all channels greater the 20 as well as channel 0.
 	# Then the mean and standard deviation are printed
	results = imstat( 'myImage', chans='&gt;20;0' )
        print "Mean is: ", results['mean'], "  s.d. ", results['sigma']

        # Find statistical information for the Q stokes value only
        # then the I stokes values only, and printing out the statistical
        # values that we are interested in.
	s1 = imstat( 'myimage', stokes='Q' )
	s2 = imstat( 'myimage', stokes='I' )
        print &quot;       |  MIN  |   MAX  | MEAN&quot;
        print &quot;  Q    | &quot;,s1['min'][0],&quot;  |  ",s1['max'][0],&quot;  |  ",,&quot;  |  ",s1['mean'][0]
        print &quot;  I    | &quot;,s2['min'][0],&quot;  |  ",s2['max'][0],&quot;  |  ",,&quot;  |  ",s2['mean'][0]

# evaluate statistics for each spectral plane in an ra x dec x frequency image
ia.fromshape("", [20,30,40])
# give pixels non-zero values
ia.addnoise()
# These are the display axes, the calculation of statistics occurs
# for each (hyper)plane along axes not listed in the axes parameter,
# in this case axis 2 (the frequency axis)
# display the rms for each frequency plane (your mileage will vary with
# the values).
stats = ia.statistics(axes=[0,1])
 stats["rms"]
  Out[10]: 
array([ 0.99576014,  1.03813124,  0.97749186,  0.97587883,  1.04189885,
        1.03784776,  1.03371549,  1.03153074,  1.00841606,  0.947155  ,
        0.97335404,  0.94389403,  1.0010221 ,  0.97151822,  1.03942156,
        1.01158476,  0.96957082,  1.04212773,  1.00589049,  0.98696715,
        1.00451481,  1.02307892,  1.03102005,  0.97334671,  0.95209879,
        1.02088714,  0.96999902,  0.98661619,  1.01039267,  0.96842754,
        0.99464947,  1.01536798,  1.02466023,  0.96956468,  0.98090756,
        0.9835844 ,  0.95698935,  1.05487967,  0.99846411,  0.99634868])


</example>

</task>

</casaxml>
